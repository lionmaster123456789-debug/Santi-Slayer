<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Santi Slayer - Rogue-lite Pro</title>
    <style>
        body { margin: 0; background: #1a1a1a; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        canvas { background: #2ecc71; display: block; cursor: crosshair; }
        #ui { position: absolute; top: 20px; left: 20px; pointer-events: none; background: rgba(0,0,0,0.5); padding: 15px; border-radius: 10px; border: 2px solid #fff; }
        .btn-back { position: absolute; top: 20px; right: 20px; padding: 12px 24px; background: #e74c3c; color: white; text-decoration: none; border-radius: 8px; font-weight: bold; border: 2px solid #c0392b; transition: 0.3s; }
        .btn-back:hover { background: #ff4d4d; transform: scale(1.1); }
        #upgrade-menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 30px; border-radius: 15px; display: none; text-align: center; border: 3px solid #f1c40f; }
        button { padding: 12px 25px; margin: 10px; cursor: pointer; background: #27ae60; border: none; color: white; font-weight: bold; border-radius: 5px; font-size: 16px; }
        button:hover { background: #2ecc71; }
    </style>
</head>
<body>

    <div id="ui">
        <div style="font-size: 24px; color: #f1c40f;">Kills: <span id="score">0</span></div>
        <div style="font-size: 18px;">HP: <span id="hp">100</span> / 100</div>
    </div>

    <a href="https://rhinogamescom.wordpress.com" class="btn-back">⬅ GET BACK</a>

    <canvas id="gameCanvas"></canvas>

    <div id="upgrade-menu">
        <h2 style="color: #f1c40f;">Level Up! Wähle einen Bonus</h2>
        <button onclick="upgrade('damage')">Feuerrate erhöhen</button>
        <button onclick="upgrade('speed')">Lauftempo +1</button>
        <button onclick="upgrade('hp')">Vollheilung</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Welt-Einstellungen
        const WORLD_SIZE = 3000;
        let canvasW, canvasH;
        function resize() {
            canvasW = canvas.width = window.innerWidth;
            canvasH = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        let player = { x: WORLD_SIZE/2, y: WORLD_SIZE/2, size: 25, speed: 5, hp: 100, fireRate: 500 };
        let camera = { x: 0, y: 0 };
        let projectiles = [];
        let enemies = [];
        let environment = [];
        let score = 0;
        let keys = {};
        let lastShot = 0;
        let gameActive = true;

        // Bäume und Steine generieren
        for(let i=0; i<60; i++) {
            environment.push({
                x: Math.random() * WORLD_SIZE,
                y: Math.random() * WORLD_SIZE,
                type: Math.random() > 0.5 ? 'tree' : 'stone',
                size: 30 + Math.random() * 40
            });
        }

        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function spawnSnake() {
            if(!gameActive || enemies.length > 30) return;
            const x = Math.random() * WORLD_SIZE;
            const y = Math.random() * WORLD_SIZE;
            // Nur spawnen, wenn weit weg vom Spieler
            if(Math.hypot(player.x - x, player.y - y) < 600) return spawnSnake();
            
            enemies.push({
                segments: Array.from({length: 8}, () => ({x, y})),
                speed: 2 + Math.random() * 2,
                color: `hsl(${100 + Math.random() * 40}, 70%, 40%)`
            });
        }
        setInterval(spawnSnake, 1500);

        function upgrade(type) {
            if(type === 'damage') player.fireRate = Math.max(150, player.fireRate - 70);
            if(type === 'speed') player.speed += 1;
            if(type === 'hp') player.hp = 100;
            document.getElementById('upgrade-menu').style.display = 'none';
            gameActive = true;
        }

        function update() {
            if(!gameActive) return;

            // Player movement
            if(keys['w'] && player.y > 0) player.y -= player.speed;
            if(keys['s'] && player.y < WORLD_SIZE) player.y += player.speed;
            if(keys['a'] && player.x > 0) player.x -= player.speed;
            if(keys['d'] && player.x < WORLD_SIZE) player.x += player.speed;

            // Camera follow
            camera.x = player.x - canvasW / 2;
            camera.y = player.y - canvasH / 2;

            // Auto-Schuss-Logik
            const now = Date.now();
            if(now - lastShot > player.fireRate && enemies.length > 0) {
                // Finde nächsten Gegner
                let closest = null;
                let minDist = Infinity;
                enemies.forEach(en => {
                    const d = Math.hypot(player.x - en.segments[0].x, player.y - en.segments[0].y);
                    if(d < minDist) { minDist = d; closest = en; }
                });

                if(closest && minDist < 600) {
                    const angle = Math.atan2(closest.segments[0].y - player.y, closest.segments[0].x - player.x);
                    projectiles.push({ x: player.x, y: player.y, vx: Math.cos(angle) * 10, vy: Math.sin(angle) * 10 });
                    lastShot = now;
                }
            }

            // Projectiles update
            projectiles.forEach((p, pi) => {
                p.x += p.vx; p.y += p.vy;
                if(p.x < 0 || p.x > WORLD_SIZE || p.y < 0 || p.y > WORLD_SIZE) projectiles.splice(pi, 1);
            });

            // Enemies (Snakes) update
            enemies.forEach((en, ei) => {
                let head = en.segments[0];
                const angle = Math.atan2(player.y - head.y, player.x - head.x);
                
                // Kopf bewegt sich zum Spieler
                let newHead = {
                    x: head.x + Math.cos(angle) * en.speed,
                    y: head.y + Math.sin(angle) * en.speed
                };
                en.segments.unshift(newHead);
                en.segments.pop();

                // Collision Player
                if(Math.hypot(player.x - head.x, player.y - head.y) < player.size) {
                    player.hp -= 0.3;
                    if(player.hp <= 0) location.reload();
                }

                // Collision mit Projectile
                projectiles.forEach((p, pi) => {
                    if(Math.hypot(p.x - head.x, p.y - head.y) < 20) {
                        enemies.splice(ei, 1);
                        projectiles.splice(pi, 1);
                        score++;
                        if(score % 10 === 0) {
                            gameActive = false;
                            document.getElementById('upgrade-menu').style.display = 'block';
                        }
                    }
                });
            });

            draw();
            document.getElementById('score').innerText = score;
            document.getElementById('hp').innerText = Math.floor(player.hp);
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvasW, canvasH);
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw World Grid
            ctx.strokeStyle = "rgba(0,0,0,0.1)";
            for(let i=0; i<=WORLD_SIZE; i+=100) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, WORLD_SIZE); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(WORLD_SIZE, i); ctx.stroke();
            }

            // Draw Environment (Trees & Stones)
            environment.forEach(obj => {
                ctx.fillStyle = obj.type === 'tree' ? '#1b5e20' : '#7f8c8d';
                ctx.beginPath();
                if(obj.type === 'tree') {
                    ctx.arc(obj.x, obj.y, obj.size, 0, Math.PI*2);
                } else {
                    ctx.rect(obj.x, obj.y, obj.size, obj.size);
                }
                ctx.fill();
            });

            // Draw Player
            ctx.fillStyle = '#3498db';
            ctx.shadowBlur = 15; ctx.shadowColor = '#3498db';
            ctx.beginPath(); ctx.arc(player.x, player.y, player.size, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            // Draw Projectiles
            ctx.fillStyle = '#f1c40f';
            projectiles.forEach(p => {
                ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
            });

            // Draw Snakes
            enemies.forEach(en => {
                ctx.fillStyle = en.color;
                en.segments.forEach((seg, i) => {
                    const size = 12 - (i * 1); // Schlange wird zum Ende hin dünner
                    ctx.beginPath(); ctx.arc(seg.x, seg.y, Math.max(size, 4), 0, Math.PI*2); ctx.fill();
                });
            });

            ctx.restore();
        }

        update();
    </script>
</body>
</html>
