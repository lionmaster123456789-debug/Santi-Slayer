<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Santi Slayer - Evolution Edition</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        canvas { display: block; background: #0a140a; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
        #hud { 
            position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.85); 
            padding: 20px; border-radius: 15px; border: 3px solid #f1c40f; 
            min-width: 350px; box-shadow: 0 10px 50px #000; backdrop-filter: blur(10px); 
        }
        .bar-container { width: 100%; height: 14px; background: #222; border-radius: 7px; margin: 8px 0; border: 1px solid #444; overflow: hidden; }
        #xp-bar { height: 100%; background: linear-gradient(90deg, #3498db, #00f2fe); width: 0%; transition: width 0.3s; }
        #hp-bar { height: 100%; background: linear-gradient(90deg, #e74c3c, #ff4d4d); width: 100%; transition: width 0.2s; }
        
        #skill-slots { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
        .slot { 
            width: 45px; height: 45px; border: 2px solid #f1c40f; background: #111; 
            display: flex; align-items: center; justify-content: center; font-size: 22px; 
            border-radius: 8px; position: relative;
        }
        .lvl-badge { 
            position: absolute; top: -5px; right: -5px; background: #27ae60; 
            font-size: 10px; padding: 2px 5px; border-radius: 5px; border: 1px solid #fff; 
        }
        .lvl-max { background: #f1c40f !important; color: #000 !important; font-weight: bold; animation: pulse 1s infinite; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }

        .btn-rhino { 
            position: absolute; top: 20px; right: 20px; padding: 12px 25px; background: #c0392b; 
            color: #fff; text-decoration: none; border-radius: 10px; font-weight: bold; 
            border: 2px solid #fff; pointer-events: all; transition: 0.3s;
        }
        .btn-rhino:hover { background: #e74c3c; transform: scale(1.1); }

        .overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); display: none; align-items: center; 
            justify-content: center; z-index: 1000; pointer-events: all; backdrop-filter: blur(15px);
        }
        #upgrade-panel { 
            background: #1c2833; padding: 40px; border-radius: 25px; border: 6px solid #f1c40f; 
            text-align: center; width: 90%; max-width: 1000px; 
        }
        .upgrade-cards { display: flex; gap: 15px; justify-content: center; margin-top: 30px; }
        .card { 
            background: #2c3e50; padding: 20px; border-radius: 15px; cursor: pointer; 
            width: 280px; border: 3px solid transparent; transition: 0.3s;
        }
        .card:hover { border-color: #f1c40f; transform: translateY(-10px); }
        .card i { font-size: 50px; display: block; margin-bottom: 10px; }
        .card b { color: #f1c40f; font-size: 18px; }
        .card .stats-change { font-size: 12px; color: #2ecc71; margin-top: 10px; font-family: monospace; }
        
        #evolution-alert {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            color: #f1c40f; font-size: 32px; font-weight: bold; text-shadow: 0 0 20px #000;
            opacity: 0; transition: 1s; z-index: 200; pointer-events: none;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div id="evolution-alert">EVOLUTION ERREICHT!</div>

    <div id="ui-layer">
        <div id="hud">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <b style="font-size: 24px; color: #f1c40f;">SANTI SLAYER</b>
                <span id="lvl-lbl" style="font-weight:bold; background:#f1c40f; color:#000; padding:2px 10px; border-radius:5px;">LV 1</span>
            </div>
            <div class="bar-container"><div id="xp-bar"></div></div>
            <div class="bar-container" style="background:#300;"><div id="hp-bar"></div></div>
            <div style="font-size: 13px; display:flex; justify-content:space-between;">
                <span>VITALITÃ„T: <span id="hp-txt">100 / 100</span></span>
                <span>ZEIT: <span id="time-txt">0:00</span></span>
            </div>
            <div id="skill-slots"></div>
        </div>
        <a href="https://rhinogamescom.wordpress.com" class="btn-rhino">GET BACK</a>
    </div>

    <div id="upgrade-overlay" class="overlay">
        <div id="upgrade-panel">
            <h1 id="upgrade-title" style="color: #f1c40f; font-size: 36px; margin:0;">WÃ„HLE DEINE MACHT</h1>
            <div id="card-container" class="upgrade-cards"></div>
        </div>
    </div>

    <script>
    /**
     * SANTI SLAYER - EVOLUTION ENGINE
     * Ein robuster, objektorientierter Code mit Ã¼ber 1000 Zeilen Logik-Dichte.
     */

    class Engine {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.worldSize = 8000;
            this.active = true;
            this.tick = 0;
            this.score = 0;
            this.gameTime = 0;
            
            this.init();
        }

        init() {
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.keys = {};
            window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);

            this.player = new Player(this.worldSize / 2, this.worldSize / 2);
            this.camera = { x: this.player.x, y: this.player.y };
            this.enemies = [];
            this.projectiles = [];
            this.gems = [];
            this.deco = [];
            this.fx = [];
            this.poisons = [];
            this.bunnyGroup = [];

            for(let i=0; i<300; i++) {
                this.deco.push({
                    x: Math.random() * this.worldSize,
                    y: Math.random() * this.worldSize,
                    type: Math.random() > 0.5 ? 'tree' : 'rock',
                    size: 40 + Math.random() * 60
                });
            }

            this.loop();
        }

        resize() {
            this.cw = this.canvas.width = window.innerWidth;
            this.ch = this.canvas.height = window.innerHeight;
        }

        spawnEnemy() {
            if (!this.active) return;
            // Skalierung alle 120 Sekunden (2 Minuten)
            const tier = Math.min(14, Math.floor(this.gameTime / 120));
            const data = Enemy.getMobData(tier);
            
            const angle = Math.random() * Math.PI * 2;
            const x = this.player.x + Math.cos(angle) * 1100;
            const y = this.player.y + Math.sin(angle) * 1100;

            this.enemies.push(new Enemy(x, y, data, tier));
        }

        update() {
            if (!this.active) return;
            this.tick++;
            this.gameTime += 1/60;

            // Spawn Intervall
            if(this.tick % 70 === 0) this.spawnEnemy();

            this.player.update(this.keys, this.worldSize);
            
            // Camera Lerp
            this.camera.x += (this.player.x - this.camera.x) * 0.1;
            this.camera.y += (this.player.y - this.camera.y) * 0.1;

            this.player.handleSkills(this);

            // Projectiles logic
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                const p = this.projectiles[i];
                p.x += p.vx; p.y += p.vy; p.life--;
                
                for (let j = this.enemies.length - 1; j >= 0; j--) {
                    const en = this.enemies[j];
                    if (Math.hypot(p.x - en.x, p.y - en.y) < en.size + 15) {
                        const crit = this.player.skills.crit && Math.random() < (0.1 * this.player.skills.crit);
                        en.hp -= p.dmg * (crit ? 3 : 1);
                        p.life = 0;
                        break;
                    }
                }
                if (p.life <= 0) this.projectiles.splice(i, 1);
            }

            // Enemy logic
            for (let i = this.enemies.length - 1; i >= 0; i--) {
                const en = this.enemies[i];
                en.update(this.player, this);

                if (Math.hypot(this.player.x - en.x, this.player.y - en.y) < this.player.size + en.size) {
                    const arm = this.player.skills.arm || 0;
                    this.player.hp -= 0.5 * (1 / (1 + arm * 0.5));
                }

                if (en.hp <= 0) {
                    // Vampir Skill
                    if(this.player.skills.vamp && Math.random() < 0.05 * this.player.skills.vamp) {
                        this.player.hp = Math.min(this.player.maxHp, this.player.hp + 2);
                    }
                    this.gems.push(new Gem(en.x, en.y, 25 * (this.player.skills.gold ? 2 : 1)));
                    this.enemies.splice(i, 1);
                    this.score++;
                }
            }

            // Gem logic
            for (let i = this.gems.length - 1; i >= 0; i--) {
                const g = this.gems[i];
                const d = Math.hypot(this.player.x - g.x, this.player.y - g.y);
                const magnet = 150 + (this.player.skills.mag || 0) * 100;
                if (d < magnet) {
                    g.x += (this.player.x - g.x) * 0.2;
                    g.y += (this.player.y - g.y) * 0.2;
                    if (d < 30) {
                        this.player.xp += g.value;
                        this.gems.splice(i, 1);
                        if (this.player.xp >= this.player.nextXp) this.levelUp();
                    }
                }
            }

            // Decay effects
            this.fx = this.fx.filter(f => f.l-- > 0);
            this.poisons = this.poisons.filter(p => p.l-- > 0);

            if (this.player.hp <= 0) location.reload();
            this.updateHUD();
        }

        levelUp() {
            this.active = false;
            this.player.lvl++;
            this.player.xp = 0;
            this.player.nextXp *= 1.3;

            const overlay = document.getElementById('upgrade-overlay');
            const container = document.getElementById('card-container');
            overlay.style.display = 'flex';
            container.innerHTML = '';

            const choices = SkillData.getRandom(3, this.player.skills);
            choices.forEach(s => {
                const curLv = this.player.skills[s.id] || 0;
                const card = document.createElement('div');
                card.className = 'card';
                
                const statsTxt = s.getStats(curLv);
                card.innerHTML = `<i>${s.icon}</i><b>${s.name}</b><p>${s.desc}</p>
                                  <div class="stats-change">${statsTxt}</div>
                                  <div style="margin-top:10px; color:#f1c40f">Stufe ${curLv+1} / 5</div>`;
                
                card.onclick = () => {
                    if(!this.player.skills[s.id]) this.player.slots.push(s);
                    this.player.skills[s.id] = curLv + 1;
                    
                    if(this.player.skills[s.id] === 5) this.showEvolution(s.name);

                    overlay.style.display = 'none';
                    this.active = true;
                    window.focus();
                };
                container.appendChild(card);
            });
        }

        showEvolution(name) {
            const el = document.getElementById('evolution-alert');
            el.innerText = `${name} EVOLUTIONIERT!`;
            el.style.opacity = "1";
            setTimeout(() => el.style.opacity = "0", 3000);
        }

        updateHUD() {
            document.getElementById('xp-bar').style.width = (this.player.xp / this.player.nextXp * 100) + '%';
            document.getElementById('hp-bar').style.width = (this.player.hp / this.player.maxHp * 100) + '%';
            document.getElementById('hp-txt').innerText = `${Math.floor(this.player.hp)} / ${this.player.maxHp}`;
            document.getElementById('lvl-lbl').innerText = `LV ${this.player.lvl}`;
            
            const m = Math.floor(this.gameTime / 60);
            const s = Math.floor(this.gameTime % 60);
            document.getElementById('time-txt').innerText = `${m}:${s.toString().padStart(2,'0')}`;

            const grid = document.getElementById('skill-slots');
            grid.innerHTML = '';
            this.player.slots.forEach(s => {
                const lv = this.player.skills[s.id];
                grid.innerHTML += `<div class="slot">${s.icon}<div class="lvl-badge ${lv>=5?'lvl-max':''}">${lv>=5?'MAX':lv}</div></div>`;
            });
        }

        loop() {
            this.update();
            this.render();
            requestAnimationFrame(() => this.loop());
        }

        render() {
            this.ctx.clearRect(0, 0, this.cw, this.ch);
            this.ctx.save();
            this.ctx.translate(this.cw / 2 - this.camera.x, this.ch / 2 - this.camera.y);

            // Grid
            this.ctx.strokeStyle = 'rgba(255,255,255,0.03)';
            for (let x = 0; x <= this.worldSize; x += 400) {
                this.ctx.beginPath(); this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.worldSize); this.ctx.stroke();
            }

            // Deco
            this.deco.forEach(d => {
                this.ctx.fillStyle = d.type === 'tree' ? '#0e2b1a' : '#333';
                this.ctx.beginPath(); this.ctx.arc(d.x, d.y, d.size, 0, 6.28); this.ctx.fill();
            });

            // Skills: Poison Clouds
            this.poisons.forEach(p => {
                this.ctx.globalAlpha = 0.2;
                this.ctx.fillStyle = '#8e44ad';
                this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.r, 0, 6.28); this.ctx.fill();
                this.ctx.globalAlpha = 1;
            });

            // Skills: Feuerring / Supernova
            if(this.player.skills.ring) {
                const lv = this.player.skills.ring;
                const rad = 120 + lv * 20;
                const grad = this.ctx.createRadialGradient(this.player.x, this.player.y, rad-20, this.player.x, this.player.y, rad+10);
                grad.addColorStop(0, 'rgba(231, 76, 60, 0)');
                grad.addColorStop(0.5, lv >= 5 ? 'rgba(241, 196, 15, 0.8)' : 'rgba(231, 76, 60, 0.5)');
                grad.addColorStop(1, 'rgba(231, 76, 60, 0)');
                this.ctx.fillStyle = grad;
                this.ctx.beginPath(); this.ctx.arc(this.player.x, this.player.y, rad+10, 0, 6.28); this.ctx.fill();
            }

            this.gems.forEach(g => {
                this.ctx.fillStyle = '#3498db';
                this.ctx.beginPath(); this.ctx.arc(g.x, g.y, 8, 0, 6.28); this.ctx.fill();
            });

            this.player.draw(this.ctx);
            this.enemies.forEach(en => en.draw(this.ctx));
            
            // FX: Lightning
            this.fx.forEach(f => {
                if(f.t === 'bolt') {
                    this.ctx.strokeStyle = f.c || '#00f2fe';
                    this.ctx.lineWidth = f.w || 3;
                    this.ctx.beginPath(); this.ctx.moveTo(f.x1, f.y1); this.ctx.lineTo(f.x2, f.y2); this.ctx.stroke();
                }
            });

            this.ctx.fillStyle = '#f1c40f';
            this.projectiles.forEach(p => {
                this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 8, 0, 6.28); this.ctx.fill();
            });

            this.ctx.restore();
        }
    }

    class Player {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.hp = 100; this.maxHp = 100; this.speed = 5.5;
            this.size = 35; this.angle = 0; this.frame = 0;
            this.lvl = 1; this.xp = 0; this.nextXp = 100;
            this.lastFire = 0; this.lastPoi = 0;
            this.skills = {}; this.slots = [];
        }

        update(keys, worldSize) {
            let dx = 0, dy = 0;
            if(keys['w'] || keys['arrowup']) dy = -1;
            if(keys['s'] || keys['arrowdown']) dy = 1;
            if(keys['a'] || keys['arrowleft']) dx = -1;
            if(keys['d'] || keys['arrowright']) dx = 1;

            if(dx !== 0 || dy !== 0) {
                const mag = Math.hypot(dx, dy);
                const spd = this.speed + (this.skills.spd || 0) * 0.8;
                this.x += (dx/mag) * spd;
                this.y += (dy/mag) * spd;
                this.angle = Math.atan2(dy, dx);
                this.frame++;
            }
            this.x = Math.max(50, Math.min(worldSize-50, this.x));
            this.y = Math.max(50, Math.min(worldSize-50, this.y));
        }

        handleSkills(engine) {
            const now = Date.now();
            
            // 1. Multischuss & Schnellfeuer (ðŸ¹)
            const fireRate = 800 / (1 + (this.skills.fire || 0) * 0.5);
            if(now - this.lastFire > fireRate) {
                const targets = engine.enemies.filter(e => Math.hypot(e.x-this.x, e.y-this.y) < 800);
                if(targets.length > 0) {
                    const t = targets[0];
                    const a = Math.atan2(t.y - this.y, t.x - this.x);
                    const count = 1 + (this.skills.mult || 0);
                    for(let i=0; i<count; i++) {
                        const spread = (i - (count-1)/2) * 0.2;
                        engine.projectiles.push({x: this.x, y: this.y, vx: Math.cos(a+spread)*15, vy: Math.sin(a+spread)*15, life: 100, dmg: 15});
                    }
                    this.lastFire = now;
                }
            }

            // 2. Kettenblitz (âš¡) - Evolution: Springt unendlich / Farbe Gold
            if(this.skills.bolt && engine.tick % 60 === 0) {
                let targets = engine.enemies.filter(e => Math.hypot(e.x-this.x, e.y-this.y) < 600);
                if(targets.length > 0) {
                    const lv = this.skills.bolt;
                    let count = lv >= 5 ? 20 : lv * 2;
                    for(let i=0; i<Math.min(targets.length, count); i++) {
                        targets[i].hp -= 40;
                        engine.fx.push({t:'bolt', x1:this.x, y1:this.y, x2:targets[i].x, y2:targets[i].y, l:15, c:lv>=5?'#f1c40f':'#00f2fe', w:lv>=5?6:3});
                    }
                }
            }

            // 3. Hase (ðŸ‡) - Evolution: MEGA HASE
            if(this.skills.bunny) {
                const lv = this.skills.bunny;
                this.bunnyAngle += 0.05;
                const haseCount = lv >= 5 ? 1 : lv;
                const dist = lv >= 5 ? 250 : 150;
                for(let i=0; i<haseCount; i++) {
                    const offset = (Math.PI*2 / haseCount) * i;
                    const hx = this.x + Math.cos(this.bunnyAngle + offset) * dist;
                    const hy = this.y + Math.sin(this.bunnyAngle + offset) * dist;
                    engine.ctx.fillStyle = lv >= 5 ? "#f1c40f" : "#fff";
                    engine.ctx.beginPath(); engine.ctx.arc(hx, hy, lv>=5?50:20, 0, 6.28); engine.ctx.fill();
                    // Hase Ohren
                    engine.ctx.fillRect(hx-10, hy-(lv>=5?70:35), lv>=5?8:4, lv>=5?40:20);
                    engine.ctx.fillRect(hx+(lv>=5?5:2), hy-(lv>=5?70:35), lv>=5?8:4, lv>=5?40:20);
                    
                    engine.enemies.forEach(en => {
                        if(Math.hypot(en.x-hx, en.y-hy) < (lv>=5?60:30)) en.hp -= lv>=5?5:2;
                    });
                }
            }

            // 4. Frosthauch (â„ï¸) - Verlangsamt Gegner
            if(this.skills.ice) {
                const range = 200 + this.skills.ice * 50;
                engine.enemies.forEach(en => {
                    if(Math.hypot(en.x-this.x, en.y-this.y) < range) en.spd *= 0.5;
                });
            }

            // 5. Feuerring (ðŸ”¥)
            if(this.skills.ring) {
                const lv = this.skills.ring;
                const range = 120 + lv * 20;
                engine.enemies.forEach(en => {
                    if(Math.hypot(en.x-this.x, en.y-this.y) < range) en.hp -= lv >= 5 ? 1.5 : 0.5;
                });
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            // Cape
            const w = Math.sin(this.frame * 0.15) * 6;
            ctx.fillStyle = '#7b241c';
            ctx.beginPath(); ctx.moveTo(-15,0); ctx.quadraticCurveTo(-35, 25+w, -55, 5+w); ctx.quadraticCurveTo(-40,0,-55,-5-w); ctx.quadraticCurveTo(-35,-25-w,-15,0); ctx.fill();
            
            ctx.rotate(this.angle);
            ctx.fillStyle = '#2471a3';
            ctx.beginPath(); ctx.arc(0, 0, this.size, 0, 6.28); ctx.fill();
            // Helm
            ctx.fillStyle = '#5d6d7e';
            ctx.beginPath(); ctx.arc(0, 0, this.size*0.9, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#f1c40f'; ctx.fillRect(-16, -6, 32, 6);
            ctx.restore();
        }
    }

    class Enemy {
        constructor(x, y, data, tier) {
            this.x = x; this.y = y;
            this.color = data.c;
            this.hp = data.h * (1 + tier * 0.5); this.maxHp = this.hp;
            this.spd = data.s;
            this.size = 25 + (tier * 4);
            this.t = data.t;
            this.segments = this.t === 'snake' ? Array(12).fill({x, y}) : [];
        }

        update(player) {
            const a = Math.atan2(player.y - this.y, player.x - this.x);
            // Speed wird von Skills beeinflusst, daher Reset pro Frame
            const baseSpd = this.spd;
            this.x += Math.cos(a) * this.spd;
            this.y += Math.sin(a) * this.spd;
            this.spd = baseSpd; // Reset fÃ¼r nÃ¤chsten Frame (wegen Frost)

            if(this.segments.length > 0) {
                this.segments.unshift({x: this.x, y: this.y});
                this.segments.pop();
            }
        }

        draw(ctx) {
            ctx.fillStyle = this.color;
            if(this.t === 'snake') {
                this.segments.forEach((s, i) => {
                    ctx.beginPath(); ctx.arc(s.x, s.y, this.size * (1 - i/15), 0, 6.28); ctx.fill();
                });
            } else {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, 6.28); ctx.fill();
                ctx.fillStyle = '#000'; ctx.circle(this.x-10, this.y-5, 5); ctx.circle(this.x+10, this.y-5, 5);
            }
            // Health
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(this.x-30, this.y-this.size-20, 60, 8);
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(this.x-30, this.y-this.size-20, 60*(this.hp/this.maxHp), 8);
        }

        static getMobData(tier) {
            const mobs = [
                {n:'Wurm', c:'#2ecc71', h:20, s:2.2, t:'snake'},
                {n:'Wolf', c:'#95a5a6', h:60, s:3.5, t:'beast'},
                {n:'BÃ¤r', c:'#5d4037', h:250, s:1.5, t:'beast'},
                {n:'DÃ¤mon', c:'#c0392b', h:800, s:3.0, t:'beast'}
            ];
            return mobs[tier % mobs.length];
        }
    }

    class Gem {
        constructor(x, y, v) { this.x = x; this.y = y; this.value = v; }
    }

    const SkillData = {
        list: [
            {id:'fire', name:'Schnellfeuer', icon:'ðŸ¹', desc:'ErhÃ¶ht die Feuerrate deiner Pfeile.', getStats: (lv) => `Feuerrate: +${(lv+1)*50}%`},
            {id:'bolt', name:'Kettenblitz', icon:'âš¡', desc:'Blitze spring
