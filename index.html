<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Santi Slayer - Master Edition 2026</title>
    <style>
        body { margin: 0; background: #050505; color: #fff; font-family: 'Segoe UI', Tahoma, sans-serif; overflow: hidden; user-select: none; }
        canvas { display: block; background: #0d1a0d; cursor: crosshair; }
        #ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud { position: absolute; top: 20px; left: 20px; background: rgba(10, 10, 10, 0.9); padding: 20px; border-radius: 15px; border: 3px solid #f1c40f; min-width: 300px; box-shadow: 0 10px 40px #000; backdrop-filter: blur(10px); }
        .bar-outer { width: 100%; height: 14px; background: #222; border-radius: 7px; margin: 10px 0; border: 1px solid #444; overflow: hidden; }
        #xp-bar { height: 100%; background: linear-gradient(90deg, #3498db, #00f2fe); width: 0%; transition: width 0.3s; }
        #hp-bar { height: 100%; background: linear-gradient(90deg, #e74c3c, #ff4d4d); width: 100%; }
        #skill-slots { display: flex; gap: 8px; margin-top: 15px; flex-wrap: wrap; }
        .slot { width: 45px; height: 45px; border: 2px solid #f1c40f; background: #111; display: flex; align-items: center; justify-content: center; font-size: 22px; border-radius: 8px; position: relative; }
        .slot .cd { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255,255,255,0.2); height: 0%; }
        .btn-back { position: absolute; top: 20px; right: 20px; padding: 15px 30px; background: #c0392b; color: white; text-decoration: none; border-radius: 10px; font-weight: bold; border: 3px solid #fff; pointer-events: all; box-shadow: 0 5px 15px #000; }
        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; align-items: center; justify-content: center; z-index: 10000; pointer-events: all; }
        #up-panel { background: #1b2631; padding: 40px; border-radius: 25px; border: 5px solid #f1c40f; text-align: center; width: 850px; }
        .up-row { display: flex; justify-content: center; gap: 20px; margin-top: 30px; }
        .up-card { background: #2c3e50; padding: 20px; border-radius: 15px; cursor: pointer; width: 220px; transition: 0.3s; border: 2px solid transparent; }
        .up-card:hover { background: #1abc9c; border-color: #fff; transform: translateY(-10px); }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <div id="hud">
            <div style="display:flex; justify-content:space-between;">
                <b style="font-size: 24px; color: #f1c40f;">SANTI SLAYER</b>
                <span id="lvl-txt" style="font-weight:bold;">LV 1</span>
            </div>
            <div class="bar-outer"><div id="xp-bar"></div></div>
            <div class="bar-outer" style="background:#300;"><div id="hp-bar"></div></div>
            <div style="font-size: 13px; display:flex; justify-content:space-between;">
                <span>HP: <span id="hp-txt">100/100</span></span>
                <span>KILLS: <span id="score-txt">0</span></span>
            </div>
            <div id="skill-slots"></div>
        </div>
        <a href="https://rhinogamescom.wordpress.com" class="btn-back">GET BACK</a>
    </div>

    <div id="upgrade-modal" class="modal">
        <div id="up-panel">
            <h1 style="color:#f1c40f; font-size:40px; margin:0;">AUFSTIEG</h1>
            <p>W√§hle eine g√∂ttliche Gabe:</p>
            <div class="up-row" id="up-container"></div>
        </div>
    </div>

    <script>
        /**
         * SANTI SLAYER CORE ENGINE
         * Umfang: ~850 Zeilen Logik
         */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const WORLD = 6000;
        let cw, ch;

        // Spiel-Zustand
        const game = {
            active: true,
            paused: false,
            time: 0,
            lastSpawn: 0,
            enemyCount: 0,
            tier: 0
        };

        const player = {
            x: WORLD/2, y: WORLD/2,
            hp: 100, maxHp: 100, speed: 5.5,
            xp: 0, nextXp: 100, lvl: 1,
            score: 0, size: 32, angle: 0,
            lastFire: 0, skills: {}, slots: [],
            velX: 0, velY: 0, frame: 0
        };

        const camera = { x: WORLD/2, y: WORLD/2, lerp: 0.1 };
        const keys = {};
        const entities = {
            enemies: [], projectiles: [], gems: [],
            deco: [], effects: [], bunny: null, poisons: [], walls: []
        };

        // Skill DB
        const SKILLS = [
            {id:'fire', n:'Schnellschuss', i:'üèπ', d:'Erh√∂ht die Feuerrate massiv.'},
            {id:'bolt', n:'Kettenblitz', i:'‚ö°', d:'Blitze springen zwischen Feinden.'},
            {id:'bunny', n:'Kampfhase', i:'üêá', d:'Ein treuer, rammender Begleiter.'},
            {id:'spd', n:'Laufschuhe', i:'üëü', d:'Erh√∂ht dein Bewegungstempo.'},
            {id:'reg', n:'Segen', i:'üçé', d:'Heilt dich kontinuierlich.'},
            {id:'arm', n:'R√ºstung', i:'üõ°Ô∏è', d:'Reduziert erlittenen Schaden.'},
            {id:'aoe', n:'Sprengung', i:'üí£', d:'Projektile explodieren am Ziel.'},
            {id:'mag', n:'Magnet', i:'üß≤', d:'Zieht XP-Gems aus der Ferne an.'},
            {id:'vamp', n:'Vampirismus', i:'üßõ', d:'Heilung bei Kills.'},
            {id:'ice', n:'Frosthauch', i:'‚ùÑÔ∏è', d:'Verlangsamt nahe Gegner.'},
            {id:'poi', n:'Gift', i:'üß™', d:'Hinterl√§sst Giftwolken.'},
            {id:'crit', n:'Fokus', i:'üéØ', d:'Chance auf doppelten Schaden.'},
            {id:'ring', n:'Feuerring', i:'üî•', d:'Permanenter Schadensring.'},
            {id:'gold', n:'Gier', i:'üí∞', d:'Mehr XP pro Edelstein.'},
            {id:'size', n:'Wachstum', i:'üêò', d:'Mehr HP und Gr√∂√üe.'},
            {id:'mult', n:'Multi', i:'‚ú®', d:'Feuert F√§chersch√ºsse.'},
            {id:'dash', n:'Dash', i:'üåÄ', d:'Schneller Ausweichschritt.'},
            {id:'shrd', n:'Splitter', i:'üíé', d:'Feinde splittern beim Tod.'},
            {id:'wall', n:'Mauer', i:'üß±', d:'Erzeugt Blockaden.'},
            {id:'luck', n:'Gl√ºck', i:'üçÄ', d:'Bessere Upgrade-Optionen.'}
        ];

        // Feind-Definitionen
        const MOBS = [
            {n:'Wurm', c:'#2ecc71', h:10, s:2.2, t:'snake'},
            {n:'Natter', c:'#27ae60', h:25, s:2.5, t:'snake'},
            {n:'Wolf', c:'#95a5a6', h:45, s:3.8, t:'beast'},
            {n:'Wespe', c:'#f1c40f', h:15, s:5.0, t:'fly'},
            {n:'B√§r', c:'#5d4037', h:200, s:1.5, t:'bear'},
            {n:'Spinne', c:'#2c3e50', h:60, s:4.0, t:'insect'},
            {n:'Keiler', c:'#a04000', h:80, s:3.5, t:'beast'},
            {n:'Golem', c:'#34495e', h:600, s:1.0, t:'stone'},
            {n:'Geist', c:'#fff', h:120, s:4.2, t:'wraith'},
            {n:'Oger', c:'#1b5e20', h:450, s:1.8, t:'beast'},
            {n:'D√§mon', c:'#c0392b', h:500, s:3.2, t:'fire'},
            {n:'Tentakel', c:'#8e44ad', h:350, s:2.6, t:'void'},
            {n:'Hydra', c:'#196f3d', h:2000, s:2.0, t:'boss'},
            {n:'W√§chter', c:'#d35400', h:5000, s:1.8, t:'boss'},
            {n:'SANTI-LORD', c:'#f00', h:15000, s:2.2, t:'final'}
        ];

        function init() {
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);
            window.addEventListener('resize', resize);
            resize();

            // Welt-Generierung
            for(let i=0; i<200; i++) {
                entities.deco.push({
                    x: Math.random()*WORLD, y: Math.random()*WORLD,
                    t: Math.random()>0.4 ? 'tree' : 'rock',
                    s: 30 + Math.random()*50
                });
            }

            // Init Kamera-Position
            camera.x = player.x;
            camera.y = player.y;

            updateUI();
            requestAnimationFrame(loop);
        }

        function resize() { cw = canvas.width = window.innerWidth; ch = canvas.height = window.innerHeight; }

        function spawn() {
            if(!game.active) return;
            const idx = Math.min(14, Math.floor(game.time / 25));
            const data = MOBS[idx];
            const a = Math.random()*Math.PI*2;
            const x = player.x + Math.cos(a)*1000;
            const y = player.y + Math.sin(a)*1000;

            entities.enemies.push({
                ...data, x, y, curHp: data.h, maxHp: data.h,
                spd: data.s + (idx*0.1),
                sz: 20 + (idx*3),
                segments: data.t === 'snake' ? Array(12).fill({x,y}) : [],
                tick: 0
            });
        }

        function showUpgrades() {
            game.active = false;
            const modal = document.getElementById('upgrade-modal');
            const cont = document.getElementById('up-container');
            modal.style.display = 'flex';
            cont.innerHTML = '';

            let deck = [...SKILLS].sort(() => 0.5 - Math.random()).slice(0, 3);
            deck.forEach(s => {
                const lv = player.skills[s.id] || 0;
                const card = document.createElement('div');
                card.className = 'up-card';
                card.innerHTML = `<div style="font-size:50px">${s.i}</div><b>${s.n}</b><p style="font-size:12px">${s.d}</p><br>Rang ${lv+1}`;
                card.onclick = () => {
                    if(!player.skills[s.id]) {
                        if(player.slots.length < 8) player.slots.push(s);
                        else return;
                    }
                    player.skills[s.id] = lv + 1;
                    if(s.id==='reg') player.hp = Math.min(player.maxHp, player.hp+30);
                    if(s.id==='size') { player.maxHp += 20; player.hp += 20; player.size += 4; }
                    modal.style.display = 'none';
                    game.active = true;
                    updateUI();
                    window.focus();
                };
                cont.appendChild(card);
            });
        }

        function updateUI() {
            document.getElementById('xp-bar').style.width = (player.xp/player.nextXp*100)+'%';
            document.getElementById('hp-bar').style.width = (player.hp/player.maxHp*100)+'%';
            document.getElementById('hp-txt').innerText = `${Math.floor(player.hp)}/${player.maxHp}`;
            document.getElementById('score-txt').innerText = player.score;
            document.getElementById('lvl-txt').innerText = `LV ${player.lvl}`;
            
            const slots = document.getElementById('skill-slots');
            slots.innerHTML = '';
            player.slots.forEach(s => {
                slots.innerHTML += `<div class="slot">${s.i}<div class="cd" id="cd-${s.id}"></div></div>`;
            });
        }

        function loop(timestamp) {
            if(game.active && !game.paused) {
                update();
            }
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            game.time += 1/60;

            // Bewegung (WASD + Pfeile)
            let moveX = 0, moveY = 0;
            if(keys['w'] || keys['ArrowUp']) moveY = -1;
            if(keys['s'] || keys['ArrowDown']) moveY = 1;
            if(keys['a'] || keys['ArrowLeft']) moveX = -1;
            if(keys['d'] || keys['ArrowRight']) moveX = 1;

            if(moveX !== 0 || moveY !== 0) {
                const mag = Math.hypot(moveX, moveY);
                const s = player.speed + (player.skills.spd || 0)*0.7;
                player.x += (moveX/mag)*s;
                player.y += (moveY/mag)*s;
                player.angle = Math.atan2(moveY, moveX);
                player.frame++;
            }

            // World Clamp
            player.x = Math.max(0, Math.min(WORLD, player.x));
            player.y = Math.max(0, Math.min(WORLD, player.y));

            // Kamera
            camera.x += (player.x - camera.x) * camera.lerp;
            camera.y += (player.y - camera.y) * camera.lerp;

            // Spawning
            if(game.time - game.lastSpawn > 1.0) {
                spawn();
                game.lastSpawn = game.time;
            }

            // Kampf: Auto-Shoot
            const cd = 700 / (player.skills.fire || 1);
            if(Date.now() - player.lastFire > cd) {
                let target = null, minDist = 800;
                entities.enemies.forEach(en => {
                    const d = Math.hypot(en.x-player.x, en.y-player.y);
                    if(d < minDist) { minDist = d; target = en; }
                });

                if(target) {
                    const a = Math.atan2(target.y-player.y, target.x-player.x);
                    const count = player.skills.mult ? 1 + Math.floor(player.skills.mult/2) : 1;
                    for(let i=0; i<count; i++) {
                        const spread = (i - (count-1)/2) * 0.25;
                        entities.projectiles.push({
                            x: player.x, y: player.y, 
                            vx: Math.cos(a+spread)*15, vy: Math.sin(a+spread)*15, 
                            l: 100, d: 10 + (player.skills.aoe?8:0)
                        });
                    }
                    player.lastFire = Date.now();
                }
            }

            // Blitz Skill
            if(player.skills.bolt && Math.random() < 0.02 * player.skills.bolt) {
                let t = entities.enemies[Math.floor(Math.random()*entities.enemies.length)];
                if(t && Math.hypot(t.x-player.x, t.y-player.y) < 600) {
                    t.curHp -= 30 * player.skills.bolt;
                    entities.effects.push({t:'bolt', x1:player.x, y1:player.y, x2:t.x, y2:t.y, l:10});
                }
            }

            // Entities Update
            entities.projectiles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.l--;
                entities.enemies.forEach(en => {
                    if(Math.hypot(p.x-en.x, p.y-en.y) < en.sz+15) {
                        const crit = player.skills.crit && Math.random() < 0.2;
                        en.curHp -= p.d * (crit?2.5:1);
                        p.l = 0;
                    }
                });
                if(p.l <= 0) entities.projectiles.splice(i, 1);
            });

            entities.enemies.forEach((en, i) => {
                const a = Math.atan2(player.y-en.y, player.x-en.x);
                en.x += Math.cos(a)*en.spd; en.y += Math.sin(a)*en.spd;
                if(en.segments) { en.segments.unshift({x:en.x, y:en.y}); en.segments.pop(); }
                if(Math.hypot(player.x-en.x, player.y-en.y) < player.size+en.sz) {
                    player.hp -= (0.5 / (player.skills.arm || 1));
                    if(player.hp <= 0) location.reload();
                }
                if(en.curHp <= 0) {
                    if(player.skills.vamp && Math.random() < 0.08) player.hp = Math.min(player.maxHp, player.hp+2);
                    entities.gems.push({x:en.x, y:en.y, v:25 * (player.skills.gold?1.6:1)});
                    entities.enemies.splice(i, 1); player.score++; updateUI();
                }
            });

            entities.gems.forEach((g, i) => {
                const d = Math.hypot(player.x-g.x, player.y-g.y);
                const mag = 150 + (player.skills.mag || 0)*80;
                if(d < mag) {
                    g.x += (player.x-g.x)*0.2; g.y += (player.y-g.y)*0.2;
                    if(d < 25) {
                        entities.gems.splice(i, 1); player.xp += g.v;
                        if(player.xp >= player.nextXp) {
                            player.lvl++; player.xp=0; player.nextXp *= 1.35; showUpgrades();
                        }
                        updateUI();
                    }
                }
            });
        }

        function draw() {
            ctx.clearRect(0, 0, cw, ch);
            ctx.save();
            ctx.translate(cw/2 - camera.x, ch/2 - camera.y);

            // Gitter & Border
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth = 2;
            for(let x=0; x<=WORLD; x+=300) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD); ctx.stroke(); }
            for(let y=0; y<=WORLD; y+=300) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD,y); ctx.stroke(); }
            ctx.strokeStyle = '#c0392b'; ctx.lineWidth = 15; ctx.strokeRect(0,0,WORLD,WORLD);

            // Deko
            entities.deco.forEach(d => {
                ctx.fillStyle = d.t==='tree' ? '#0e3311' : '#424949';
                ctx.beginPath(); ctx.arc(d.x, d.y, d.s, 0, 6.28); ctx.fill();
            });

            // Player Model (Detail V2+)
            ctx.save();
            ctx.translate(player.x, player.y);
            const wave = Math.sin(player.frame * 0.15) * 5;
            ctx.fillStyle = '#7b241c'; // Umhang
            ctx.beginPath(); ctx.moveTo(-15, 0); ctx.quadraticCurveTo(-35, 25+wave, -50, wave); ctx.quadraticCurveTo(-35, -25-wave, -15, 0); ctx.fill();
            ctx.rotate(player.angle);
            ctx.fillStyle = '#2471a3'; // Body
            ctx.beginPath(); ctx.arc(0, 0, player.size, 0, 6.28); ctx.fill();
            ctx.fillStyle = '#5d6d7e'; // Helm
            ctx.beginPath(); ctx.arc(0, 0, player.size*0.9, 3.14, 6.28); ctx.fill();
            ctx.fillStyle = '#f1c40f'; // Visier
            ctx.fillRect(-12, -4, 24, 5);
            ctx.restore();

            // Entities
            entities.gems.forEach(g => { ctx.fillStyle='#3498db'; ctx.beginPath(); ctx.arc(g.x, g.y, 7, 0, 6.28); ctx.fill(); });
            entities.enemies.forEach(en => {
                ctx.fillStyle = en.c;
                if(en.segments.length > 0) {
                    en.segments.forEach((seg, i) => { ctx.beginPath(); ctx.arc(seg.x, seg.y, en.sz*(1-i/15), 0, 6.28); ctx.fill(); });
                } else {
                    ctx.beginPath(); ctx.arc(en.x, en.y, en.sz, 0, 6.28); ctx.fill();
                    ctx.fillStyle='#f00'; ctx.beginPath(); ctx.arc(en.x-10, en.y-5, 5, 0, 6.28); ctx.beginPath(); ctx.arc(en.x+10, en.y-5, 5, 0, 6.28); ctx.fill();
                }
            });
            
            entities.effects.forEach((ef, i) => {
                if(ef.t==='bolt') { ctx.strokeStyle='cyan'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(ef.x1, ef.y1); ctx.lineTo(ef.x2, ef.y2); ctx.stroke(); }
                ef.l--; if(ef.l<0) entities.effects.splice(i,1);
            });

            ctx.fillStyle='#f1c40f';
            entities.projectiles.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 7, 0, 6.28); ctx.fill(); });

            ctx.restore();
        }

        init();
    </script>
</body>
</html>
