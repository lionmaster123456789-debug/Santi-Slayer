<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Santi Slayer - Master Edition</title>
    <style>
        body { margin: 0; background: #050505; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; user-select: none; }
        canvas { display: block; background: #1a2e1a; }
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #hud { position: absolute; top: 20px; left: 20px; background: rgba(10, 10, 10, 0.9); padding: 20px; border-radius: 15px; border: 3px solid #f1c40f; min-width: 280px; pointer-events: none; }
        .xp-bar { width: 100%; height: 12px; background: #222; border-radius: 6px; margin: 10px 0; overflow: hidden; border: 1px solid #444; }
        #xp-fill { height: 100%; background: #3498db; width: 0%; transition: width 0.3s; }
        #hp-bar { width: 100%; height: 8px; background: #300; border-radius: 4px; margin-bottom: 5px; }
        #hp-fill { height: 100%; background: #e74c3c; width: 100%; }
        #slots { display: flex; gap: 8px; margin-top: 15px; flex-wrap: wrap; }
        .slot { width: 40px; height: 40px; border: 2px solid #f1c40f; background: #111; display: flex; align-items: center; justify-content: center; font-size: 20px; border-radius: 8px; position: relative; overflow: hidden; }
        .slot .cd { position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255,255,255,0.3); height: 0%; }
        .btn-back { position: absolute; top: 20px; right: 20px; padding: 12px 24px; background: #c0392b; color: white; text-decoration: none; border-radius: 10px; font-weight: bold; border: 2px solid #fff; pointer-events: all; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 9999; pointer-events: all; }
        #upgrade-box { background: #1c2833; padding: 30px; border-radius: 20px; border: 5px solid #f1c40f; text-align: center; width: 80%; max-width: 800px; }
        .card-container { display: flex; gap: 15px; justify-content: center; margin-top: 20px; }
        .card { background: #283747; padding: 15px; border-radius: 10px; cursor: pointer; width: 200px; border: 2px solid transparent; }
        .card:hover { border-color: #f1c40f; background: #34495e; }
        .card i { font-size: 40px; display: block; }
        .card b { color: #f1c40f; display: block; margin: 5px 0; }
        .card p { font-size: 12px; margin: 0; color: #bdc3c7; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div id="hud">
            <div style="font-size: 22px; font-weight: bold; color: #f1c40f;">SANTI SLAYER</div>
            <div class="xp-bar"><div id="xp-fill"></div></div>
            <div id="hp-bar"><div id="hp-fill"></div></div>
            <div style="font-size: 13px;">LV: <span id="lvl-txt">1</span> | Kills: <span id="score-txt">0</span></div>
            <div id="slots"></div>
        </div>
        <a href="https://rhinogamescom.wordpress.com" class="btn-back">GET BACK</a>
    </div>

    <div id="upgrade-overlay" class="overlay">
        <div id="upgrade-box">
            <h1 style="color: #f1c40f;">LEVEL UP!</h1>
            <div id="upgrade-cards" class="card-container"></div>
        </div>
    </div>

    <div id="pause-overlay" class="overlay">
        <h1 style="color: #f1c40f; font-size: 60px;">PAUSE</h1>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let cw, ch;
        const WORLD_SIZE = 5000;

        // Spiel-Variablen
        let player = {
            x: WORLD_SIZE/2, y: WORLD_SIZE/2,
            hp: 100, maxHp: 100, speed: 5,
            xp: 0, nextXp: 100, lvl: 1,
            score: 0, size: 30, angle: 0,
            slots: [], lastFire: 0
        };

        let keys = {};
        let enemies = [], projectiles = [], gems = [], decorations = [], effects = [], poisons = [], walls = [];
        let bunny = { x: 0, y: 0, angle: 0, active: false };
        let gameRunning = true, isPaused = false;
        let mySkills = {}, cooldowns = {};

        const SKILLS = [
            {id:'fire', n:'Schnellschuss', i:'ðŸ¹', d:'Feuert schneller.'},
            {id:'bolt', n:'Kettenblitz', i:'âš¡', d:'Blitze treffen Gegner.'},
            {id:'bunny', n:'Kampfhase', i:'ðŸ‡', d:'Ein rammender Hase.'},
            {id:'spd', n:'Tempo', i:'ðŸ‘Ÿ', d:'Schneller laufen.'},
            {id:'reg', n:'Heilung', i:'ðŸŽ', d:'Regeneriert HP.'},
            {id:'arm', n:'Panzer', i:'ðŸ›¡ï¸', d:'Weniger Schaden.'},
            {id:'aoe', n:'Bombe', i:'ðŸ’£', d:'FlÃ¤chenschaden.'},
            {id:'mag', n:'Magnet', i:'ðŸ§²', d:'Zieht XP an.'},
            {id:'vamp', n:'Vampir', i:'ðŸ§›', d:'HP bei Kill.'},
            {id:'ice', n:'Frost', i:'â„ï¸', d:'Gegner verlangsamen.'},
            {id:'poi', n:'Gift', i:'ðŸ§ª', d:'HinterlÃ¤sst Giftwolken.'},
            {id:'crit', n:'Fokus', i:'ðŸŽ¯', d:'Chance auf Doppel-Schaden.'},
            {id:'ring', n:'Aura', i:'ðŸ”¥', d:'Schaden um dich herum.'},
            {id:'gold', n:'Gier', i:'ðŸ’°', d:'Mehr XP pro Edelstein.'},
            {id:'size', n:'Riese', i:'ðŸ˜', d:'Mehr Max HP.'},
            {id:'mult', n:'Multi', i:'âœ¨', d:'Mehr Projektile.'},
            {id:'dash', n:'Dash', i:'ðŸŒ€', d:'Schneller Ausweichsprung.'},
            {id:'shrd', n:'Splitter', i:'ðŸ’Ž', d:'Gegner explodieren.'},
            {id:'wall', n:'Wand', i:'ðŸ§±', d:'Blockiert Gegner.'},
            {id:'luck', n:'GlÃ¼ck', i:'ðŸ€', d:'Bessere Upgrades.'}
        ];

        const ENEMIES = [
            {n:'Wurm', c:'#2ecc71', hp:15, s:2, m:'snake'},
            {n:'BÃ¤r', c:'#5d4037', hp:100, s:1.5, m:'bear'},
            {n:'Wolf', c:'#95a5a6', hp:40, s:3.5, m:'wolf'},
            {n:'Schatten', c:'#111', hp:200, s:4, m:'wraith'},
            {n:'DÃ¤mon', c:'#c0392b', hp:500, s:2.5, m:'demon'}
            // ... (weitere Typen intern berechnet)
        ];

        function init() {
            window.addEventListener('keydown', e => { 
                keys[e.key.toLowerCase()] = true;
                keys[e.key] = true; // FÃ¼r Pfeiltasten
                if(e.key.toLowerCase() === 'p') togglePause();
            });
            window.addEventListener('keyup', e => { 
                keys[e.key.toLowerCase()] = false;
                keys[e.key] = false;
            });
            window.addEventListener('resize', resize);
            resize();

            for(let i=0; i<100; i++) {
                decorations.push({x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, t: Math.random()>0.5?'tree':'stone', sz: 30+Math.random()*30});
            }
            updateUI();
            requestAnimationFrame(loop);
        }

        function resize() { cw = canvas.width = window.innerWidth; ch = canvas.height = window.innerHeight; }

        function togglePause() {
            if(!gameRunning) return;
            isPaused = !isPaused;
            document.getElementById('pause-overlay').style.display = isPaused ? 'flex' : 'none';
        }

        function spawnEnemy() {
            if(!gameRunning || isPaused) return;
            let time = (Date.now() - player.startTime)/1000;
            let level = Math.min(14, Math.floor(time / 20));
            let a = Math.random()*Math.PI*2;
            let x = player.x + Math.cos(a)*800;
            let y = player.y + Math.sin(a)*800;

            let base = ENEMIES[level % ENEMIES.length];
            enemies.push({
                ...base, x, y, curHp: base.hp + (level*20), 
                sz: 20 + (level*2), segments: Array(base.m==='snake'?8:0).fill({x,y}),
                spd: base.s + (level*0.1)
            });
        }
        setInterval(spawnEnemy, 1000);

        function updateUI() {
            document.getElementById('lvl-txt').innerText = player.lvl;
            document.getElementById('score-txt').innerText = player.score;
            document.getElementById('xp-fill').style.width = (player.xp/player.nextXp*100)+'%';
            document.getElementById('hp-fill').style.width = (player.hp/player.maxHp*100)+'%';
            
            let sDiv = document.getElementById('slots');
            sDiv.innerHTML = '';
            player.slots.forEach(s => {
                sDiv.innerHTML += `<div class="slot" id="slot-${s.id}">${s.icon}<div class="cd" id="cd-${s.id}"></div></div>`;
            });
        }

        function levelUp() {
            gameRunning = false;
            let overlay = document.getElementById('upgrade-overlay');
            let container = document.getElementById('upgrade-cards');
            container.innerHTML = '';
            overlay.style.display = 'flex';

            let pool = [...SKILLS].sort(() => 0.5 - Math.random()).slice(0, 3);
            pool.forEach(s => {
                let card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `<i>${s.icon}</i><b>${s.n}</b><p>${s.d}</p>`;
                card.onclick = () => {
                    if(!mySkills[s.id]) {
                        if(player.slots.length < 8) player.slots.push(s);
                        else return;
                    }
                    mySkills[s.id] = (mySkills[s.id]||0) + 1;
                    if(s.id === 'size') { player.maxHp += 20; player.hp += 20; }
                    if(s.id === 'reg') player.hp = Math.min(player.maxHp, player.hp + 20);
                    
                    overlay.style.display = 'none';
                    gameRunning = true;
                    updateUI();
                };
                container.appendChild(card);
            });
        }

        function loop() {
            if(gameRunning && !isPaused) {
                update();
            }
            draw();
            requestAnimationFrame(loop);
        }

        function update() {
            // Movement (WASD + Pfeiltasten)
            let mx = 0, my = 0;
            if(keys['w'] || keys['ArrowUp']) my -= 1;
            if(keys['s'] || keys['ArrowDown']) my += 1;
            if(keys['a'] || keys['ArrowLeft']) mx -= 1;
            if(keys['d'] || keys['ArrowRight']) mx += 1;

            if(mx !== 0 || my !== 0) {
                let mag = Math.hypot(mx, my);
                let speed = player.speed + (mySkills.spd||0);
                player.x += (mx/mag) * speed;
                player.y += (my/mag) * speed;
                player.angle = Math.atan2(my, mx);

                // Dash (ðŸŒ€)
                if(mySkills.dash && Math.random() < 0.01) {
                    player.x += mx * 50; player.y += my * 50;
                }
            }

            // Skills: Blitz (âš¡)
            if(mySkills.bolt && Math.random() < 0.02 * mySkills.bolt) {
                let target = enemies[Math.floor(Math.random()*enemies.length)];
                if(target) {
                    target.curHp -= 50;
                    effects.push({x1: player.x, y1: player.y, x2: target.x, y2: target.y, l: 10});
                }
            }

            // Skills: Hase (ðŸ‡)
            if(mySkills.bunny) {
                bunny.active = true;
                bunny.angle += 0.05;
                bunny.x = player.x + Math.cos(bunny.angle)*150;
                bunny.y = player.y + Math.sin(bunny.angle)*150;
                enemies.forEach(en => {
                    if(Math.hypot(en.x-bunny.x, en.y-bunny.y) < 40) en.curHp -= 1;
                });
            }

            // SchieÃŸen
            let fireRate = 600 / (mySkills.fire || 1);
            if(Date.now() - player.lastFire > fireRate) {
                let target = enemies.find(en => Math.hypot(en.x-player.x, en.y-player.y) < 600);
                if(target) {
                    let a = Math.atan2(target.y-player.y, target.x-player.x);
                    projectiles.push({x: player.x, y: player.y, vx: Math.cos(a)*12, vy: Math.sin(a)*12, l: 100});
                    player.lastFire = Date.now();
                }
            }

            // Enemies Update
            enemies.forEach((en, i) => {
                let a = Math.atan2(player.y-en.y, player.x-en.x);
                en.x += Math.cos(a) * en.spd;
                en.y += Math.sin(a) * en.spd;

                if(en.m === 'snake') {
                    en.segments.unshift({x: en.x, y: en.y});
                    en.segments.pop();
                }

                if(Math.hypot(player.x-en.x, player.y-en.y) < player.size + en.sz) {
                    player.hp -= (0.5 / (mySkills.arm||1));
                }

                projectiles.forEach((p, pi) => {
                    if(Math.hypot(p.x-en.x, p.y-en.y) < en.sz + 10) {
                        en.curHp -= 10; projectiles.splice(pi, 1);
                        if(en.curHp <= 0) {
                            if(mySkills.vamp && Math.random() < 0.05) player.hp = Math.min(player.maxHp, player.hp+1);
                            gems.push({x: en.x, y: en.y, v: 20 * (mySkills.gold||1)});
                            enemies.splice(i, 1); player.score++; updateUI();
                        }
                    }
                });
            });

            // Gems & XP
            gems.forEach((g, i) => {
                let d = Math.hypot(player.x-g.x, player.y-g.y);
                if(d < 150 + (mySkills.mag||0)*50) {
                    g.x += (player.x-g.x)*0.2; g.y += (player.y-g.y)*0.2;
                    if(d < 20) {
                        player.xp += g.v; gems.splice(i, 1);
                        if(player.xp >= player.nextXp) { player.xp=0; player.nextXp*=1.3; player.lvl++; levelUp(); }
                        updateUI();
                    }
                }
            });

            if(player.hp <= 0) location.reload();
        }

        function draw() {
            ctx.clearRect(0, 0, cw, ch);
            ctx.save();
            ctx.translate(cw/2 - player.x, ch/2 - player.y);

            // World
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            for(let x=0; x<WORLD_SIZE; x+=250) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,WORLD_SIZE); ctx.stroke(); }
            for(let y=0; y<WORLD_SIZE; y+=250) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WORLD_SIZE,y); ctx.stroke(); }

            decorations.forEach(d => {
                ctx.fillStyle = d.t==='tree'?'#145a32':'#566573';
                ctx.beginPath(); ctx.arc(d.x, d.y, d.sz, 0, 6.28); ctx.fill();
            });

            // Gems
            ctx.fillStyle = "#3498db";
            gems.forEach(g => { ctx.beginPath(); ctx.arc(g.x, g.y, 5, 0, 6.28); ctx.fill(); });

            // Hase (ðŸ‡)
            if(bunny.active) {
                ctx.fillStyle = "white";
                ctx.beginPath(); ctx.arc(bunny.x, bunny.y, 15, 0, 6.28); ctx.fill();
                ctx.fillRect(bunny.x-5, bunny.y-25, 4, 15); ctx.fillRect(bunny.x+2, bunny.y-25, 4, 15);
            }

            // Player Model
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);
            ctx.fillStyle = "#2980b9";
            ctx.beginPath(); ctx.arc(0, 0, player.size, 0, 6.28); ctx.fill();
            ctx.fillStyle = "white";
            ctx.beginPath(); ctx.arc(15, -10, 5, 0, 6.28); ctx.fill();
            ctx.beginPath(); ctx.arc(15, 10, 5, 0, 6.28); ctx.fill();
            ctx.restore();

            // Enemies
            enemies.forEach(en => {
                ctx.fillStyle = en.c;
                if(en.m === 'snake') {
                    en.segments.forEach(s => { ctx.beginPath(); ctx.arc(s.x, s.y, en.sz/2, 0, 6.28); ctx.fill(); });
                } else {
                    ctx.beginPath(); ctx.arc(en.x, en.y, en.sz, 0, 6.28); ctx.fill();
                }
            });

            // Effects
            effects.forEach((ef, i) => {
                ctx.strokeStyle = "cyan"; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(ef.x1, ef.y1); ctx.lineTo(ef.x2, ef.y2); ctx.stroke();
                ef.l--; if(ef.l<0) effects.splice(i, 1);
            });

            // Projectiles
            ctx.fillStyle = "yellow";
            projectiles.forEach(p => { p.x += p.vx; p.y += p.vy; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 6.28); ctx.fill(); });

            ctx.restore();
        }

        init();
    </script>
</body>
</html>
